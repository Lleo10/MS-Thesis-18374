# -*- coding: utf-8 -*-
"""polymer langevin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WX-w0H42XdK4zvqmSg8dkiMxoOYemfO7
"""

import random
import numpy as np
import matplotlib.pyplot as plt 
import math
from tqdm import tqdm as tqdm
from numba import njit
import warnings
import csv
warnings.filterwarnings("ignore")


#Parameters

N   = 500
N_d = 1
#rho = 0.1     #density
kB_T   = 1
dt = 0.001
zeta = 1
kappa = 1000
kappa_dp = 50
kappa_dd = 100
lb = 1 
lb_d = 1
rc2 = np.cbrt(2)
#frequency = 5000
force_strength = 300
timesteps =2000000
start = 950000
dissociation = 'yes'
rate_d = 25001


def intialize_pos(x,y,z,N):
    pathx = r'D:\Study Material\College\MS Thesis\positional data\x_eqbm.csv'
    pathy = r'D:\Study Material\College\MS Thesis\positional data\y_eqbm.csv'
    pathz = r'D:\Study Material\College\MS Thesis\positional data\z_eqbm.csv'
    filex = open(pathx)
    filey = open(pathy)
    filez = open(pathz)
  
    x = np.loadtxt(filex, delimiter=",")
    y = np.loadtxt(filey, delimiter=",")
    z = np.loadtxt(filez, delimiter=",")
    return x,y,z


def intialize_vel(Vx,Vy,Vz,N):
  KE_temp=0.0

  for i in range(N):
    Vx[i]=random.random()-0.5
    Vy[i]=random.random()-0.5
    Vz[i]=random.random()-0.5
    KE_temp = KE_temp +  (1/2)*(Vx[i]**2+Vy[i]**2+Vz[i]**2)

  Vx_sum=sum(Vx)
  Vy_sum=sum(Vy)
  Vz_sum=sum(Vz)

  for i in range(N):
    Vx[i]=Vx[i]-(Vx_sum/N)
    Vy[i]=Vy[i]-(Vy_sum/N)
    Vz[i]=Vz[i]-(Vz_sum/N)

  for i in range(N):
    Vx[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vx[i]
    Vy[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vy[i]
    Vz[i]=(math.sqrt((3*N*kB_T)/(2*KE_temp)))*Vz[i]
  return Vx, Vy, Vz

def Kinetic_E(Vx,Vy,Vz):
  KE=0
  for i in range(N):
    KE+=(1/2)*((Vx[i]**2)+(Vy[i]**2)+(Vz[i]**2))
  return KE

@njit
def force(fx,fy,fz,x,y,z,rc2): 
  ulj=0.0
  for i in range(N):
    fx[i]=0.0
    fy[i]=0.0
    fz[i]=0.0

  for i in range(N-1):
    j = (i+1)
    dx = x[i]-x[j]
    dy = y[i]-y[j]
    dz = z[i]-z[j]

    dr2 = dx**2 + dy**2 + dz**2
    dr  = math.sqrt(dr2)
    ulj   = ulj+(dr-lb)**2
    f   = kappa*(1-lb/dr)   #F_stretch
    
    Fx = -f*dx
    Fy = -f*dy 
    Fz = -f*dz

    fx[i] += Fx
    fy[i] += Fy
    fz[i] += Fz

    fx[j] -= Fx
    fy[j] -= Fy
    fz[j] -= Fz

  ulj = ulj*kappa/2   

  #Ulj
  for i in range(N-1):
    for j in range(i+1,N):
        x_diff_n=x[i]-x[j]
        y_diff_n=y[i]-y[j]
        z_diff_n=z[i]-z[j]

        r2=((x_diff_n**2)+(y_diff_n**2)+(z_diff_n**2))

        if(r2 < rc2 and r2!=0 and j != i+1 and j != i-1):
          force=48.0*(((1.0/r2)**7)-((1.0/2.0)*((1.0/r2)**4)))          #F_LJ
          fox= force*x_diff_n 
          foy= force*y_diff_n 
          foz= force*z_diff_n 

          r6 = r2**3
          rc6=rc2**3
          ulj += 4.0*(1.0/r6)*(1/r6 - 1.0)-(4.0*(1/rc6)*(1.0/rc6 - 1.0))
          #print("passed")
        else:
          fox=0.0
          foy=0.0
          foz=0.0


        fx[i] = fx[i] + fox
        fx[j] = fx[j] - fox
            
            
        fy[i] = fy[i] + foy
        fy[j] = fy[j] - foy
            
            
        fz[i] = fz[i] + foz
        fz[j] = fz[j] - foz
        

  return fx,fy,fz,ulj

def force_pull_left(fx,fy,fz,x,y,z,rc2,selected_mono1,selected_mono2):
    
    #Parameters inside function
    x_diff_tan1 = [0.0]*N
    y_diff_tan1 = [0.0]*N
    z_diff_tan1 = [0.0]*N
    
    r2_1 = [0.0]*N
    r_1 = [0.0]*N

    
    force1 = [0.0]*N
    fox1 = [0.0]*N
    foy1 = [0.0]*N
    foz1 = [0.0]*N
    
    for j in range(len(selected_mono1)):
        if ((selected_mono1[j]-1) in selected_mono2 or selected_mono1[j]==0):
            continue
        else:
            x_diff_tan1[j]=x[selected_mono1[j]]-x[selected_mono1[j]-1]
            y_diff_tan1[j]=y[selected_mono1[j]]-y[selected_mono1[j]-1]
            z_diff_tan1[j]=z[selected_mono1[j]]-z[selected_mono1[j]-1]
            
            
            r2_1[j]=((x_diff_tan1[j]**2)+(y_diff_tan1[j]**2)+(z_diff_tan1[j]**2))
            r_1[j] = np.sqrt(r2_1[j])
            
            
            force1[j] = (force_strength/r_1[j])
            fox1[j] = force1[j]*x_diff_tan1[j] 
            foy1[j] = force1[j]*y_diff_tan1[j] 
            foz1[j] = force1[j]*z_diff_tan1[j] 
              
            
            fx[selected_mono1[j]-1] = fx[selected_mono1[j]-1] + fox1[j]
            fy[selected_mono1[j]-1] = fy[selected_mono1[j]-1] + foy1[j]
            fz[selected_mono1[j]-1] = fz[selected_mono1[j]-1] + foz1[j]

    
    return fx,fy,fz

def force_pull_right(fx,fy,fz,x,y,z,rc2,selected_mono1,selected_mono2):
    
    #Parameters inside function

    x_diff_tan2 = [0.0]*N
    y_diff_tan2 = [0.0]*N
    z_diff_tan2 = [0.0]*N
    
    r2_2 = [0.0]*N
    r_2 = [0.0]*N
    
    
    force2 = [0.0]*N
    fox2 = [0.0]*N
    foy2 = [0.0]*N
    foz2 = [0.0]*N   
    
    for j in range(len(selected_mono1)):
        if ((selected_mono2[j]+1) in selected_mono1 or selected_mono2[j]==499):
            continue
        else:
            x_diff_tan2[j]=x[selected_mono2[j]]-x[selected_mono2[j]+1]
            y_diff_tan2[j]=y[selected_mono2[j]]-y[selected_mono2[j]+1]
            z_diff_tan2[j]=z[selected_mono2[j]]-z[selected_mono2[j]+1]
            
            r2_2[j]=((x_diff_tan2[j]**2)+(y_diff_tan2[j]**2)+(z_diff_tan2[j]**2))
            r_2[j] = np.sqrt(r2_2[j])
            
            force2[j] = (force_strength/r_2[j])
            fox2[j] = force2[j]*x_diff_tan2[j] 
            foy2[j] = force2[j]*y_diff_tan2[j] 
            foz2[j] = force2[j]*z_diff_tan2[j]            
        
            fx[selected_mono2[j]+1] = fx[selected_mono2[j]+1] + fox2[j]
            fy[selected_mono2[j]+1] = fy[selected_mono2[j]+1] + foy2[j]
            fz[selected_mono2[j]+1] = fz[selected_mono2[j]+1] + foz2[j]
    
    return fx,fy,fz
    
def distance_check_1(x,y,z,xd,yd,zd,selected_mono1,i):
    
    #Parameters
    x_dist_1 = [0.0]*len(selected_mono1)
    y_dist_1 = [0.0]*len(selected_mono1)
    z_dist_1 = [0.0]*len(selected_mono1)
    
    r2_dist_1 = [0.0]*len(selected_mono1)
    r_dist_1 = [0.0]*len(selected_mono1)
    
    
    x_dist_2 = [0.0]*len(selected_mono1)
    y_dist_2 = [0.0]*len(selected_mono1)
    z_dist_2 = [0.0]*len(selected_mono1)
    
    r2_dist_2 = [0.0]*len(selected_mono1)
    r_dist_2 = [0.0]*len(selected_mono1)
    
    for j in range(len(selected_mono1)):
        if ((selected_mono1[j]-1) in selected_mono2 or selected_mono1[j]==0):
            continue
        else:
            x_dist_1[j] = x[selected_mono1[j]] - xd[j][0]
            y_dist_1[j] = y[selected_mono1[j]] - yd[j][0]
            z_dist_1[j] = z[selected_mono1[j]] - zd[j][0]
            
            r2_dist_1[j] = x_dist_1[j]**2 + y_dist_1[j]**2 + z_dist_1[j]**2
            r_dist_1[j] = np.sqrt(r2_dist_1[j])
            
            
            x_dist_2[j] = x[selected_mono1[j]-1] - xd[j][0]
            y_dist_2[j] = y[selected_mono1[j]-1] - yd[j][0]
            z_dist_2[j] = z[selected_mono1[j]-1] - zd[j][0]
            
            r2_dist_2[j] = x_dist_2[j]**2 + y_dist_2[j]**2 + z_dist_2[j]**2
            r_dist_2[j] = np.sqrt(r2_dist_2[j])
            
            if(r_dist_1[j]>=r_dist_2[j]):
                selected_mono1[j] = selected_mono1[j]-1
    
    return selected_mono1

def distance_check_2(x,y,z,xd,yd,zd,selected_mono2,i):

    #Parameters

    x_dist_1 = [0.0]*len(selected_mono1)
    y_dist_1 = [0.0]*len(selected_mono1)
    z_dist_1 = [0.0]*len(selected_mono1)
    
    r2_dist_1 = [0.0]*len(selected_mono1)
    r_dist_1 = [0.0]*len(selected_mono1)
    
    
    x_dist_2 = [0.0]*len(selected_mono1)
    y_dist_2 = [0.0]*len(selected_mono1)
    z_dist_2 = [0.0]*len(selected_mono1)
    
    r2_dist_2 = [0.0]*len(selected_mono1)
    r_dist_2 = [0.0]*len(selected_mono1)
    
    for j in range(len(selected_mono1)):
        if ((selected_mono2[j]+1) in selected_mono1 or selected_mono2[j]==499):
            continue
        else:
            x_dist_1[j] = x[selected_mono2[j]] - xd[j][1]
            y_dist_1[j] = y[selected_mono2[j]] - yd[j][1]
            z_dist_1[j] = z[selected_mono2[j]] - zd[j][1]
            
            r2_dist_1[j] = x_dist_1[j]**2 + y_dist_1[j]**2 + z_dist_1[j]**2
            r_dist_1[j] = np.sqrt(r2_dist_1[j])
            
            
            x_dist_2[j] = x[selected_mono2[j]+1] - xd[j][1]
            y_dist_2[j] = y[selected_mono2[j]+1] - yd[j][1]
            z_dist_2[j] = z[selected_mono2[j]+1] - zd[j][1]
            
            r2_dist_2[j] = x_dist_2[j]**2 + y_dist_2[j]**2 + z_dist_2[j]**2
            r_dist_2[j] = np.sqrt(r2_dist_2[j])
            
            if(r_dist_1[j]>=r_dist_2[j]):
                selected_mono2[j] = selected_mono2[j]+1
    
    return selected_mono2
    
    

def update_position(x,y,z,N,dt):
  for i in range(N):
    x[i]=x[i]+Vx[i]*C
    y[i]=y[i]+Vy[i]*C
    z[i]=z[i]+Vz[i]*C

  return x,y,z

def update_velocities(Vx,Vy,Vz,N,dt,A,zeta,eta1,eta2,eta3):
  for i in range(N):
    Vx[i]=A*Vx[i]+fx[i]*dt*(1/2)+B*eta1[i]
    Vy[i]=A*Vy[i]+fy[i]*dt*(1/2)+B*eta2[i]
    Vz[i]=A*Vz[i]+fz[i]*dt*(1/2)+B*eta3[i]
  return Vx,Vy,Vz

def distance(N):
  r2 = 0
  dx = x[0]-x[N-1]
  dy = y[0]-y[N-1]
  dz = z[0]-z[N-1]
  r2 = dx**2 + dy**2 + dz**2
  dist = np.sqrt(r2)
  return dist

def ROG():
  Rcm_x=0
  Rcm_y=0
  Rcm_z=0
  Rg2=0
  for i in range(N):
    Rcm_x = Rcm_x + x[i]
    Rcm_y = Rcm_y + y[i]
    Rcm_z = Rcm_z + z[i]
  Rcm_x = Rcm_x/N
  Rcm_y = Rcm_y/N
  Rcm_z = Rcm_z/N
  for i in range(N):
    dx = x[i]-Rcm_x
    dy = y[i]-Rcm_y
    dz = z[i]-Rcm_z 

    dr2 = dx**2 + dy**2 + dz**2
    Rg2 +=dr2
  Rg2 = Rg2/N  
  return Rg2

"""DIMER CODE"""

#Initialise dimer (check where to place (on polymer directly) or (far from polymer, snaps onto polymer))
def intialize_dimer(xd,yd,zd):
    for j in range(len(selected_mono1)):
        for i in range(2):
            xd[j][i] = x[selected_mono1[j]+i]
            yd[j][i] = y[selected_mono1[j]+i]
            zd[j][i] = z[selected_mono1[j]+i]
    return xd,yd,zd

def force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2): 
   #Parameters inside function

    ulj_total=0
    
    dxd = [0.0]*len(selected_mono1)
    dyd = [0.0]*len(selected_mono1)
    dzd = [0.0]*len(selected_mono1)
    
    dr2_d = [0.0]*len(selected_mono1)
    dr_d = [0.0]*len(selected_mono1)
    
    uljd = [0.0]*len(selected_mono1)
    f_d = [0.0]*len(selected_mono1)
    
    Fx_d = [0.0]*len(selected_mono1)
    Fy_d = [0.0]*len(selected_mono1)
    Fz_d = [0.0]*len(selected_mono1)
    
    dx_dp1 = [0.0]*len(selected_mono1)
    dy_dp1 = [0.0]*len(selected_mono1)
    dz_dp1 = [0.0]*len(selected_mono1)
    
    dr2_dp1 = [0.0]*len(selected_mono1)
    dr_dp1 = [0.0]*len(selected_mono1)
    
    f_dp = [0.0]*len(selected_mono1)
    
    Fx_dp1 = [0.0]*len(selected_mono1)
    Fy_dp1 = [0.0]*len(selected_mono1)
    Fz_dp1 = [0.0]*len(selected_mono1)
    
    dx_dp2 = [0.0]*len(selected_mono1)
    dy_dp2 = [0.0]*len(selected_mono1)
    dz_dp2 = [0.0]*len(selected_mono1)
    
    dr2_dp2 = [0.0]*len(selected_mono1)
    dr_dp2 = [0.0]*len(selected_mono1)
    
    f_dp2 = [0.0]*len(selected_mono1)
    
    Fx_dp2 = [0.0]*len(selected_mono1)
    Fy_dp2 = [0.0]*len(selected_mono1)
    Fz_dp2 = [0.0]*len(selected_mono1)
    
    for j in range(len(selected_mono1)):
        
        for i in range(2):
            fxd[j][i]=0
            fyd[j][i]=0
            fzd[j][i]=0
    
      #force between 2 monomers of dimer(cohesin)
      
        dxd[j] = xd[j][0]-xd[j][1]
        dyd[j] = yd[j][0]-yd[j][1]
        dzd[j] = zd[j][0]-zd[j][1]
      
        dr2_d[j] = dxd[j]**2 + dyd[j]**2 + dzd[j]**2
        dr_d[j]  = math.sqrt(dr2_d[j])
        uljd[j]  = (kappa_dd/2)*(dr_d[j]-lb_d)**2
        f_d[j]   = kappa_dd*(1-lb_d/dr_d[j])   #F_stretch
        
        Fx_d[j] = -f_d[j]*dxd[j]
        Fy_d[j] = -f_d[j]*dyd[j] 
        Fz_d[j] = -f_d[j]*dzd[j]
      
        fxd[j][0] += Fx_d[j]
        fyd[j][0] += Fy_d[j]
        fzd[j][0] += Fz_d[j]
      
        fxd[j][1] -= Fx_d[j]
        fyd[j][1] -= Fy_d[j]
        fzd[j][1] -= Fz_d[j]
      
      
      #force between dimer and polymer
      #FOR 1
        dx_dp1[j] = x[selected_mono1[j]]-xd[j][0]
        dy_dp1[j] = y[selected_mono1[j]]-yd[j][0]
        dz_dp1[j] = z[selected_mono1[j]]-zd[j][0]
      
        dr2_dp1[j] = dx_dp1[j]**2 + dy_dp1[j]**2 + dz_dp1[j]**2
        dr_dp1[j]  = math.sqrt(dr2_dp1[j])
        uljd[j]   = (dr_dp1[j]-(0))**2
        f_dp[j]   = kappa_dp*(1-(0))   
        #(dr_dp would be zero, sort that out)
          
        Fx_dp1[j] = -f_dp[j]*dx_dp1[j]
        Fy_dp1[j] = -f_dp[j]*dy_dp1[j]
        Fz_dp1[j] = -f_dp[j]*dz_dp1[j]
          
        fxd[j][0] -= Fx_dp1[j]
        fyd[j][0] -= Fy_dp1[j]
        fzd[j][0] -= Fz_dp1[j]
          
        fx[selected_mono1[j]] += Fx_dp1[j]
        fy[selected_mono1[j]] += Fy_dp1[j]
        fz[selected_mono1[j]] += Fz_dp1[j]
        
        #dr_dp1_arr.append(dr_dp1)
        
        
        #FOR 2
        dx_dp2[j] = x[selected_mono2[j]]-xd[j][1]
        dy_dp2[j] = y[selected_mono2[j]]-yd[j][1]
        dz_dp2[j] = z[selected_mono2[j]]-zd[j][1]
      
        dr2_dp2[j] = dx_dp2[j]**2 + dy_dp2[j]**2 + dz_dp2[j]**2
        dr_dp2[j]  = math.sqrt(dr2_dp2[j])
        uljd[j]   = (dr_dp2[j]-(0))**2
        f_dp2[j]   = kappa_dp*(1-(0))   
        #(dr_dp would be zero, sort that out)
          
        Fx_dp2[j] = -f_dp2[j]*dx_dp2[j]
        Fy_dp2[j] = -f_dp2[j]*dy_dp2[j]
        Fz_dp2[j] = -f_dp2[j]*dz_dp2[j]
          
        fxd[j][1] -= Fx_dp2[j]
        fyd[j][1] -= Fy_dp2[j]
        fzd[j][1] -= Fz_dp2[j]
          
        fx[selected_mono2[j]] += Fx_dp2[j]
        fy[selected_mono2[j]] += Fy_dp2[j]
        fz[selected_mono2[j]] += Fz_dp2[j]
        
        #dr_dp2_arr.append(dr_dp2)
          
      
    for i in range(len(selected_mono1)):
        ulj_total = ulj_total + uljd[i]
    ulj_total = kappa_dp*ulj_total
    
    return fxd,fyd,fzd,ulj_total

def update_position_dimer(xd,yd,zd,dt):
    for j in range(len(selected_mono1)):  
        for i in range(2):
            xd[j][i]=xd[j][i]+Vxd[j][i]*dt+fxd[j][i]*dt*dt*(1/2)
            yd[j][i]=yd[j][i]+Vyd[j][i]*dt+fyd[j][i]*dt*dt*(1/2)
            zd[j][i]=zd[j][i]+Vzd[j][i]*dt+fzd[j][i]*dt*dt*(1/2)
    return xd,yd,zd

def update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt):
    for j in range(len(selected_mono1)): 
        for i in range(2):
            Vxd[j][i]=Vxd[j][i]+fxd[j][i]*dt*(1/2)
            Vyd[j][i]=Vyd[j][i]+fyd[j][i]*dt*(1/2)
            Vzd[j][i]=Vzd[j][i]+fzd[j][i]*dt*(1/2)
    return Vxd,Vyd,Vzd

"""END DIMER CODE"""


  


dist_arr1 = []
KE_arr1 = []
PE_arr1 = []
PED_arr1 = []
PE_total_arr1 = []
RG_arr1 = []
dr_dp1_arr = []
dr_dp2_arr = []

selected_mono1_arr = []
selected_mono2_arr = []

dimer1_distance_arr = []
dimer2_distance_arr = []

position_arr = []
positiond_arr = []
frames = []



time=np.linspace(0,20,20000)

x   = [0.0]*N
y   = [0.0]*N
z   = [0.0]*N

Vx  = [0.0]*N
Vy  = [0.0]*N
Vz  = [0.0]*N

fx  = [0.0]*N
fy  = [0.0]*N
fz  = [0.0]*N

x2  = [0.0]*N
y2  = [0.0]*N
z2  = [0.0]*N

#For Dimer

selected_mono1 = [0]*N_d
selected_mono2 = [0]*N_d

xd   = [ [0.0]*2 for i in range(len(selected_mono1))]
yd   = [ [0.0]*2 for i in range(len(selected_mono1))]
zd   = [ [0.0]*2 for i in range(len(selected_mono1))]

Vxd  = [ [0.0]*2 for i in range(len(selected_mono1))]
Vyd  = [ [0.0]*2 for i in range(len(selected_mono1))]
Vzd  = [ [0.0]*2 for i in range(len(selected_mono1))]

fxd  = [ [0.0]*2 for i in range(len(selected_mono1))]
fyd  = [ [0.0]*2 for i in range(len(selected_mono1))]
fzd  = [ [0.0]*2 for i in range(len(selected_mono1))]


  #End

for k in range(1000):
    for i in range(len(selected_mono1)):
        selected_mono1[i] = random.randint(1,N-1)
        selected_mono2[i] = selected_mono1[i] + 1
        
    check = [x+1 for x in selected_mono1]
    check2 = [x for x in selected_mono1]
    
    if any(x in selected_mono1 for x in check):
        continue
    elif any(x in selected_mono1 for x in check2):
        continue
    else:
        break
            
        
    
    
A=(2-zeta*dt)/(2+zeta*dt)
B=math.sqrt(kB_T*zeta*dt/2)
C=2*dt/(2+zeta*dt)
 
x,y,z=intialize_pos(x,y,z,N)
 #Saving initial positions 
x2=np.copy(x)
y2=np.copy(y)
z2=np.copy(z)
Vx,Vy,Vz=intialize_vel(Vx,Vy,Vz,N)
fx,fy,fz,en= force(fx,fy,fz,x,y,z,rc2)

xd,yd,zd = intialize_dimer(xd,yd,zd)
fxd,fyd,fzd,en_d = force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2)

  


for i in tqdm(range(timesteps)):
                
    '''selected_mono1_arr.append(selected_mono1)
    selected_mono2_arr.append(selected_mono2)'''
    
    '''loop_x = x[selected_mono1:selected_mono2+1]
    loop_y = y[selected_mono1:selected_mono2+1]
    loop_z = z[selected_mono1:selected_mono2+1]'''
      
      
    ''' if(i==0):
        fig = plt.figure(figsize=(20,10))  
        ax = fig.add_subplot(111, projection='3d')
        ax.set_xlim3d(-1, 501)
        ax.set_ylim3d(-5, 5)
        ax.set_zlim3d(-5, 5)
            
        ax.plot(x,y,z, color='black')
        ax.scatter(x[selected_mono1],y[selected_mono1],z[selected_mono1], color='blue')
        ax.scatter(x[selected_mono2],y[selected_mono2],z[selected_mono2], color='blue')
        ax.plot(xd,yd,zd, color='red')
        ax.scatter(xd[0],yd[0],zd[0], color='red')
        ax.scatter(xd[1],yd[1],zd[1], color='red')
      #  ax.plot(loop_x,loop_y,loop_z, color='green')
        print('dimer 1 = ',xd[0],yd[0],zd[0])
        print('mono 1 = ',x[selected_mono1],y[selected_mono1],z[selected_mono1])
        print('selected mono -1 = ',x[selected_mono1-1],y[selected_mono1-1],z[selected_mono1-1])
        print('dimer 2 = ',xd[1],yd[1],zd[1])
        print('mono 2 = ',x[selected_mono1+1],y[selected_mono1+1],z[selected_mono1+1])
        print('selected mono +2 = ',x[selected_mono1+2],y[selected_mono1+2],z[selected_mono1+2])
        plt.show()'''
      
    eta1=np.random.normal(0,1,N)  #for random force (brownian motion)
    eta2=np.random.normal(0,1,N)
    eta3=np.random.normal(0,1,N)
    Vx,Vy,Vz = update_velocities(Vx,Vy,Vz,N,dt,1,zeta,eta1,eta2,eta3)
    x,y,z = update_position(x,y,z,N,dt)
    fx,fy,fz,en= force(fx,fy,fz,x,y,z,rc2)
    Vx,Vy,Vz = update_velocities(Vx,Vy,Vz,N,dt,A,zeta,eta1,eta2,eta3)
    
        

        

    xd,yd,zd = update_position_dimer(xd,yd,zd,dt)
    Vxd,Vyd,Vzd = update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt)
    fxd,fyd,fzd,en_d= force_dimer(fxd,fyd,fzd,xd,yd,zd,rc2)
    Vxd,Vyd,Vzd = update_velocities_dimer(Vxd,Vyd,Vzd,fxd,fyd,fzd,dt)
    
    
    
np.savetxt("x_eqbm.csv", x, delimiter=",")
np.savetxt("y_eqbm.csv", y, delimiter=",")
np.savetxt("z_eqbm.csv", z, delimiter=",")

        
        
    
